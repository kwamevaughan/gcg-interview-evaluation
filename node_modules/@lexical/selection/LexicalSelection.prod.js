/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

"use strict";var e=require("lexical");function t(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var n=t((function(e){const t=new URL("https://lexical.dev/docs/error"),n=new URLSearchParams;n.append("code",e);for(let e=1;e<arguments.length;e++)n.append("v",arguments[e]);throw t.search=n.toString(),Error(`Minified Lexical error #${e}; visit ${t.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));const o=new Map;function s(e){let t=e;for(;null!=t;){if(t.nodeType===Node.TEXT_NODE)return t;t=t.firstChild}return null}function r(e){const t=e.parentNode;if(null==t)throw new Error("Should never happen");return[t,Array.from(t.childNodes).indexOf(e)]}function l(e){const t={};if(!e)return t;const n=e.split(";");for(const e of n)if(""!==e){const[n,o]=e.split(/:([^]+)/);n&&o&&(t[n.trim()]=o.trim())}return t}function i(e){let t=o.get(e);return void 0===t&&(t=l(e),o.set(e,t)),t}function c(e){let t="";for(const n in e)n&&(t+=`${n}: ${e[n]};`);return t}function f(t,n,o){let s=n.getNode(),r=o;if(e.$isElementNode(s)){const e=s.getDescendantByIndex(n.offset);null!==e&&(s=e)}for(;r>0&&null!==s;){if(e.$isElementNode(s)){const e=s.getLastDescendant();null!==e&&(s=e)}let o=s.getPreviousSibling(),l=0;if(null===o){let e=s.getParentOrThrow(),t=e.getPreviousSibling();for(;null===t;){if(e=e.getParent(),null===e){o=null;break}t=e.getPreviousSibling()}null!==e&&(l=e.isInline()?0:2,o=t)}let i=s.getTextContent();""===i&&e.$isElementNode(s)&&!s.isInline()&&(i="\n\n");const c=i.length;if(!e.$isTextNode(s)||r>=c){const t=s.getParent();s.remove(),null==t||0!==t.getChildrenSize()||e.$isRootNode(t)||t.remove(),r-=c+l,s=o}else{const o=s.getKey(),l=t.getEditorState().read((()=>{const t=e.$getNodeByKey(o);return e.$isTextNode(t)&&t.isSimpleText()?t.getTextContent():null})),f=c-r,a=i.slice(0,f);if(null!==l&&l!==i){const t=e.$getPreviousSelection();let n=s;if(s.isSimpleText())s.setTextContent(l);else{const t=e.$createTextNode(l);s.replace(t),n=t}if(e.$isRangeSelection(t)&&t.isCollapsed()){const e=t.anchor.offset;n.select(e,e)}}else if(s.isSimpleText()){const e=n.key===o;let t=n.offset;t<r&&(t=c);const l=e?t-r:0,i=e?t:f;if(e&&0===l){const[e]=s.splitText(l,i);e.remove()}else{const[,e]=s.splitText(l,i);e.remove()}}else{const t=e.$createTextNode(a);s.replace(t)}r=0}}}function a(t,s){t instanceof e.TextNode||t.isCollapsed()||n(270);const r=i(t instanceof e.TextNode?t.getStyle():t.style),l=Object.entries(s).reduce(((e,[n,o])=>("function"==typeof o?e[n]=o(r[n],t):null===o?delete e[n]:e[n]=o,e)),{...r}),f=c(l);t.setStyle(f),o.set(f,l)}function d(t){const n=e.$getSelection();if(!n)return;const o=new Map;if(e.$isRangeSelection(n))for(const t of e.$caretRangeFromSelection(n).getTextSlices())t&&o.set(t.caret.origin.getKey(),t.getSliceIndices());const s=n.getNodes();for(const n of s){if(!e.$isTextNode(n)||!n.canHaveFormat())continue;const[s,l]=(r=n,o.get(r.getKey())||[0,r.getTextContentSize()]);if(l!==s)if(e.$isTokenOrSegmented(n)||0===s&&l===n.getTextContentSize())t(n);else{t(n.splitText(s,l)[0===s?0:1])}}var r;e.$isRangeSelection(n)&&"text"===n.anchor.type&&"text"===n.focus.type&&n.anchor.key===n.focus.key&&u(n)}function u(e){if(e.isBackward()){const{anchor:t,focus:n}=e,{key:o,offset:s,type:r}=t;t.set(n.key,n.offset,n.type),n.set(o,s,r)}}function g(e,t){const n=e.getFormatType(),o=e.getIndent();n!==t.getFormatType()&&t.setFormat(n),o!==t.getIndent()&&t.setIndent(o)}function p(e){return e.getNode().isAttached()}function h(t){let n=t;for(;null!==n&&!e.$isRootOrShadowRoot(n);){const e=n.getLatest(),t=n.getParent();0===e.getChildrenSize()&&n.remove(!0),n=t}}function y(t,o,s,r,l=null){if(0===o.length)return;const i=o[0],c=new Map,f=[];let a=e.$isElementNode(i)?i:i.getParentOrThrow();a.isInline()&&(a=a.getParentOrThrow());let d=!1;for(;null!==a;){const t=a.getPreviousSibling();if(null!==t){a=t,d=!0;break}if(a=a.getParentOrThrow(),e.$isRootOrShadowRoot(a))break}const u=new Set;for(let t=0;t<s;t++){const n=o[t];e.$isElementNode(n)&&0===n.getChildrenSize()&&u.add(n.getKey())}const g=new Set;for(let t=0;t<s;t++){const s=o[t];let l=s.getParent();if(null!==l&&l.isInline()&&(l=l.getParent()),null!==l&&e.$isLeafNode(s)&&!g.has(s.getKey())){const t=l.getKey();if(void 0===c.get(t)){const n=r();n.setFormat(l.getFormatType()),n.setIndent(l.getIndent()),f.push(n),c.set(t,n),l.getChildren().forEach((t=>{n.append(t),g.add(t.getKey()),e.$isElementNode(t)&&t.getChildrenKeys().forEach((e=>g.add(e)))})),h(l)}}else if(u.has(s.getKey())){e.$isElementNode(s)||n(179);const t=r();t.setFormat(s.getFormatType()),t.setIndent(s.getIndent()),f.push(t),s.remove(!0)}}if(null!==l)for(let e=0;e<f.length;e++){const t=f[e];l.append(t)}let y=null;if(e.$isRootOrShadowRoot(a))if(d)if(null!==l)a.insertAfter(l);else for(let e=f.length-1;e>=0;e--){const t=f[e];a.insertAfter(t)}else{const t=a.getFirstChild();if(e.$isElementNode(t)&&(a=t),null===t)if(l)a.append(l);else for(let e=0;e<f.length;e++){const t=f[e];a.append(t),y=t}else if(null!==l)t.insertBefore(l);else for(let e=0;e<f.length;e++){const n=f[e];t.insertBefore(n),y=n}}else if(l)a.insertAfter(l);else for(let e=f.length-1;e>=0;e--){const t=f[e];a.insertAfter(t),y=t}const $=e.$getPreviousSelection();e.$isRangeSelection($)&&p($.anchor)&&p($.focus)?e.$setSelection($.clone()):null!==y?y.selectEnd():t.dirty=!0}function $(e,t,n,o){e.modify(t?"extend":"move",n,o)}function S(t){const n=t.anchor.getNode();return"rtl"===(e.$isRootNode(n)?n:n.getParentOrThrow()).getDirection()}function m(e,t,n){const o=i(e.getStyle());return null!==o&&o[t]||n}function N(e,t){let n=e;for(;null!==n&&null!==n.getParent()&&!t(n);)n=n.getParentOrThrow();return t(n)?n:null}const x=f;exports.$cloneWithProperties=e.$cloneWithProperties,exports.$selectAll=e.$selectAll,exports.$addNodeStyle=function(e){const t=e.getStyle(),n=l(t);o.set(t,n)},exports.$copyBlockFormatIndent=g,exports.$ensureForwardRangeSelection=u,exports.$forEachSelectedTextNode=d,exports.$getSelectionStyleValueForProperty=function(t,n,o=""){let s=null;const r=t.getNodes(),l=t.anchor,c=t.focus,f=t.isBackward(),a=f?c.offset:l.offset,d=f?c.getNode():l.getNode();if(e.$isRangeSelection(t)&&t.isCollapsed()&&""!==t.style){const e=i(t.style);if(null!==e&&n in e)return e[n]}for(let t=0;t<r.length;t++){const l=r[t];if((0===t||0!==a||!l.is(d))&&e.$isTextNode(l)){const e=m(l,n,o);if(null===s)s=e;else if(s!==e){s="";break}}}return null===s?o:s},exports.$isAtNodeEnd=function(t){if("text"===t.type)return t.offset===t.getNode().getTextContentSize();const o=t.getNode();return e.$isElementNode(o)||n(177),t.offset===o.getChildrenSize()},exports.$isParentElementRTL=S,exports.$moveCaretSelection=$,exports.$moveCharacter=function(e,t,n){const o=S(e);$(e,t,n?!o:o,"character")},exports.$patchStyleText=function(t,n){if(e.$isRangeSelection(t)&&t.isCollapsed())return a(t,n);d((e=>{a(e,n)}))},exports.$setBlocksType=function(t,n,o=g){if(null===t)return;const s=t.getStartEndPoints(),r=new Map;let l=null;if(s){const[t,n]=s;l=e.$createRangeSelection(),l.anchor.set(t.key,t.offset,t.type),l.focus.set(n.key,n.offset,n.type);const o=N(t.getNode(),e.INTERNAL_$isBlock),i=N(n.getNode(),e.INTERNAL_$isBlock);e.$isElementNode(o)&&r.set(o.getKey(),o),e.$isElementNode(i)&&r.set(i.getKey(),i)}for(const n of t.getNodes())e.$isElementNode(n)&&e.INTERNAL_$isBlock(n)&&r.set(n.getKey(),n);for(const[e,t]of r){const s=n();o(t,s),t.replace(s,!0),l&&(e===l.anchor.key&&(l.anchor.key=s.getKey()),e===l.focus.key&&(l.focus.key=s.getKey()))}l&&t.is(e.$getSelection())&&e.$setSelection(l)},exports.$shouldOverrideDefaultCharacterSelection=function(t,n){const o=e.$getAdjacentNode(t.focus,n);return e.$isDecoratorNode(o)&&!o.isIsolated()||e.$isElementNode(o)&&!o.isInline()&&!o.canBeEmpty()},exports.$sliceSelectedTextNodeContent=function(t,n){const o=t.getStartEndPoints();if(n.isSelected(t)&&!n.isSegmented()&&!n.isToken()&&null!==o){const[s,r]=o,l=t.isBackward(),i=s.getNode(),c=r.getNode(),f=n.is(i),a=n.is(c);if(f||a){const[o,s]=e.$getCharacterOffsets(t),r=i.is(c),f=n.is(l?c:i),a=n.is(l?i:c);let d,u=0;if(r)u=o>s?s:o,d=o>s?o:s;else if(f){u=l?s:o,d=void 0}else if(a){u=0,d=l?o:s}return n.__text=n.__text.slice(u,d),n}}return n},exports.$trimTextContentFromAnchor=f,exports.$wrapNodes=function(t,n,o=null){const s=t.getStartEndPoints(),r=s?s[0]:null,l=t.getNodes(),i=l.length;if(null!==r&&(0===i||1===i&&"element"===r.type&&0===r.getNode().getChildrenSize())){const e="text"===r.type?r.getNode().getParentOrThrow():r.getNode(),t=e.getChildren();let s=n();return s.setFormat(e.getFormatType()),s.setIndent(e.getIndent()),t.forEach((e=>s.append(e))),o&&(s=o.append(s)),void e.replace(s)}let c=null,f=[];for(let s=0;s<i;s++){const r=l[s];e.$isRootOrShadowRoot(r)?(y(t,f,f.length,n,o),f=[],c=r):null===c||null!==c&&e.$hasAncestor(r,c)?f.push(r):(y(t,f,f.length,n,o),f=[r])}y(t,f,f.length,n,o)},exports.createDOMRange=function(t,n,o,l,i){const c=n.getKey(),f=l.getKey(),a=document.createRange();let d=t.getElementByKey(c),u=t.getElementByKey(f),g=o,p=i;if(e.$isTextNode(n)&&(d=s(d)),e.$isTextNode(l)&&(u=s(u)),void 0===n||void 0===l||null===d||null===u)return null;"BR"===d.nodeName&&([d,g]=r(d)),"BR"===u.nodeName&&([u,p]=r(u));const h=d.firstChild;d===u&&null!=h&&"BR"===h.nodeName&&0===g&&0===p&&(p=1);try{a.setStart(d,g),a.setEnd(u,p)}catch(e){return null}return!a.collapsed||g===p&&c===f||(a.setStart(u,p),a.setEnd(d,g)),a},exports.createRectsFromDOMRange=function(e,t){const n=e.getRootElement();if(null===n)return[];const o=n.getBoundingClientRect(),s=getComputedStyle(n),r=parseFloat(s.paddingLeft)+parseFloat(s.paddingRight),l=Array.from(t.getClientRects());let i,c=l.length;l.sort(((e,t)=>{const n=e.top-t.top;return Math.abs(n)<=3?e.left-t.left:n}));for(let e=0;e<c;e++){const t=l[e],n=i&&i.top<=t.top&&i.top+i.height>t.top&&i.left+i.width>t.left,s=t.width+r===o.width;n||s?(l.splice(e--,1),c--):i=t}return l},exports.getCSSFromStyleObject=c,exports.getStyleObjectFromCSS=i,exports.trimTextContentFromAnchor=x;
