/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

import{$isTextNode as e,$getCharacterOffsets as t,$isElementNode as n,$isRootNode as o,$getNodeByKey as l,$getPreviousSelection as r,$createTextNode as s,$isRangeSelection as i,$getSelection as c,$caretRangeFromSelection as f,$isTokenOrSegmented as u,TextNode as a,$createRangeSelection as g,INTERNAL_$isBlock as d,$setSelection as p,$isRootOrShadowRoot as h,$hasAncestor as y,$isLeafNode as m,$getAdjacentNode as S,$isDecoratorNode as T}from"lexical";export{$cloneWithProperties,$selectAll}from"lexical";function x(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var v=x((function(e){const t=new URL("https://lexical.dev/docs/error"),n=new URLSearchParams;n.append("code",e);for(let e=1;e<arguments.length;e++)n.append("v",arguments[e]);throw t.search=n.toString(),Error(`Minified Lexical error #${e}; visit ${t.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));const w=new Map;function N(e){let t=e;for(;null!=t;){if(t.nodeType===Node.TEXT_NODE)return t;t=t.firstChild}return null}function C(e){const t=e.parentNode;if(null==t)throw new Error("Should never happen");return[t,Array.from(t.childNodes).indexOf(e)]}function P(t,n,o,l,r){const s=n.getKey(),i=l.getKey(),c=document.createRange();let f=t.getElementByKey(s),u=t.getElementByKey(i),a=o,g=r;if(e(n)&&(f=N(f)),e(l)&&(u=N(u)),void 0===n||void 0===l||null===f||null===u)return null;"BR"===f.nodeName&&([f,a]=C(f)),"BR"===u.nodeName&&([u,g]=C(u));const d=f.firstChild;f===u&&null!=d&&"BR"===d.nodeName&&0===a&&0===g&&(g=1);try{c.setStart(f,a),c.setEnd(u,g)}catch(e){return null}return!c.collapsed||a===g&&s===i||(c.setStart(u,g),c.setEnd(f,a)),c}function k(e,t){const n=e.getRootElement();if(null===n)return[];const o=n.getBoundingClientRect(),l=getComputedStyle(n),r=parseFloat(l.paddingLeft)+parseFloat(l.paddingRight),s=Array.from(t.getClientRects());let i,c=s.length;s.sort(((e,t)=>{const n=e.top-t.top;return Math.abs(n)<=3?e.left-t.left:n}));for(let e=0;e<c;e++){const t=s[e],n=i&&i.top<=t.top&&i.top+i.height>t.top&&i.left+i.width>t.left,l=t.width+r===o.width;n||l?(s.splice(e--,1),c--):i=t}return s}function E(e){const t={};if(!e)return t;const n=e.split(";");for(const e of n)if(""!==e){const[n,o]=e.split(/:([^]+)/);n&&o&&(t[n.trim()]=o.trim())}return t}function K(e){let t=w.get(e);return void 0===t&&(t=E(e),w.set(e,t)),t}function I(e){let t="";for(const n in e)n&&(t+=`${n}: ${e[n]};`);return t}function B(e,n){const o=e.getStartEndPoints();if(n.isSelected(e)&&!n.isSegmented()&&!n.isToken()&&null!==o){const[l,r]=o,s=e.isBackward(),i=l.getNode(),c=r.getNode(),f=n.is(i),u=n.is(c);if(f||u){const[o,l]=t(e),r=i.is(c),f=n.is(s?c:i),u=n.is(s?i:c);let a,g=0;if(r)g=o>l?l:o,a=o>l?o:l;else if(f){g=s?l:o,a=void 0}else if(u){g=0,a=s?o:l}return n.__text=n.__text.slice(g,a),n}}return n}function F(e){if("text"===e.type)return e.offset===e.getNode().getTextContentSize();const t=e.getNode();return n(t)||v(177),e.offset===t.getChildrenSize()}function O(t,c,f){let u=c.getNode(),a=f;if(n(u)){const e=u.getDescendantByIndex(c.offset);null!==e&&(u=e)}for(;a>0&&null!==u;){if(n(u)){const e=u.getLastDescendant();null!==e&&(u=e)}let f=u.getPreviousSibling(),g=0;if(null===f){let e=u.getParentOrThrow(),t=e.getPreviousSibling();for(;null===t;){if(e=e.getParent(),null===e){f=null;break}t=e.getPreviousSibling()}null!==e&&(g=e.isInline()?0:2,f=t)}let d=u.getTextContent();""===d&&n(u)&&!u.isInline()&&(d="\n\n");const p=d.length;if(!e(u)||a>=p){const e=u.getParent();u.remove(),null==e||0!==e.getChildrenSize()||o(e)||e.remove(),a-=p+g,u=f}else{const n=u.getKey(),o=t.getEditorState().read((()=>{const t=l(n);return e(t)&&t.isSimpleText()?t.getTextContent():null})),f=p-a,g=d.slice(0,f);if(null!==o&&o!==d){const e=r();let t=u;if(u.isSimpleText())u.setTextContent(o);else{const e=s(o);u.replace(e),t=e}if(i(e)&&e.isCollapsed()){const n=e.anchor.offset;t.select(n,n)}}else if(u.isSimpleText()){const e=c.key===n;let t=c.offset;t<a&&(t=p);const o=e?t-a:0,l=e?t:f;if(e&&0===o){const[e]=u.splitText(o,l);e.remove()}else{const[,e]=u.splitText(o,l);e.remove()}}else{const e=s(g);u.replace(e)}a=0}}}function b(e){const t=e.getStyle(),n=E(t);w.set(t,n)}function R(e,t){e instanceof a||e.isCollapsed()||v(270);const n=K(e instanceof a?e.getStyle():e.style),o=Object.entries(t).reduce(((t,[o,l])=>("function"==typeof l?t[o]=l(n[o],e):null===l?delete t[o]:t[o]=l,t)),{...n}),l=I(o);e.setStyle(l),w.set(l,o)}function z(e,t){if(i(e)&&e.isCollapsed())return R(e,t);A((e=>{R(e,t)}))}function A(t){const n=c();if(!n)return;const o=new Map;if(i(n))for(const e of f(n).getTextSlices())e&&o.set(e.caret.origin.getKey(),e.getSliceIndices());const l=n.getNodes();for(const n of l){if(!e(n)||!n.canHaveFormat())continue;const[l,s]=(r=n,o.get(r.getKey())||[0,r.getTextContentSize()]);if(s!==l)if(u(n)||0===l&&s===n.getTextContentSize())t(n);else{t(n.splitText(l,s)[0===l?0:1])}}var r;i(n)&&"text"===n.anchor.type&&"text"===n.focus.type&&n.anchor.key===n.focus.key&&M(n)}function M(e){if(e.isBackward()){const{anchor:t,focus:n}=e,{key:o,offset:l,type:r}=t;t.set(n.key,n.offset,n.type),n.set(o,l,r)}}function _(e,t){const n=e.getFormatType(),o=e.getIndent();n!==t.getFormatType()&&t.setFormat(n),o!==t.getIndent()&&t.setIndent(o)}function L(e,t,o=_){if(null===e)return;const l=e.getStartEndPoints(),r=new Map;let s=null;if(l){const[e,t]=l;s=g(),s.anchor.set(e.key,e.offset,e.type),s.focus.set(t.key,t.offset,t.type);const o=Q(e.getNode(),d),i=Q(t.getNode(),d);n(o)&&r.set(o.getKey(),o),n(i)&&r.set(i.getKey(),i)}for(const t of e.getNodes())n(t)&&d(t)&&r.set(t.getKey(),t);for(const[e,n]of r){const l=t();o(n,l),n.replace(l,!0),s&&(e===s.anchor.key&&(s.anchor.key=l.getKey()),e===s.focus.key&&(s.focus.key=l.getKey()))}s&&e.is(c())&&p(s)}function $(e){return e.getNode().isAttached()}function D(e){let t=e;for(;null!==t&&!h(t);){const e=t.getLatest(),n=t.getParent();0===e.getChildrenSize()&&t.remove(!0),t=n}}function j(e,t,n=null){const o=e.getStartEndPoints(),l=o?o[0]:null,r=e.getNodes(),s=r.length;if(null!==l&&(0===s||1===s&&"element"===l.type&&0===l.getNode().getChildrenSize())){const e="text"===l.type?l.getNode().getParentOrThrow():l.getNode(),o=e.getChildren();let r=t();return r.setFormat(e.getFormatType()),r.setIndent(e.getIndent()),o.forEach((e=>r.append(e))),n&&(r=n.append(r)),void e.replace(r)}let i=null,c=[];for(let o=0;o<s;o++){const l=r[o];h(l)?(U(e,c,c.length,t,n),c=[],i=l):null===i||null!==i&&y(l,i)?c.push(l):(U(e,c,c.length,t,n),c=[l])}U(e,c,c.length,t,n)}function U(e,t,o,l,s=null){if(0===t.length)return;const c=t[0],f=new Map,u=[];let a=n(c)?c:c.getParentOrThrow();a.isInline()&&(a=a.getParentOrThrow());let g=!1;for(;null!==a;){const e=a.getPreviousSibling();if(null!==e){a=e,g=!0;break}if(a=a.getParentOrThrow(),h(a))break}const d=new Set;for(let e=0;e<o;e++){const o=t[e];n(o)&&0===o.getChildrenSize()&&d.add(o.getKey())}const y=new Set;for(let e=0;e<o;e++){const o=t[e];let r=o.getParent();if(null!==r&&r.isInline()&&(r=r.getParent()),null!==r&&m(o)&&!y.has(o.getKey())){const e=r.getKey();if(void 0===f.get(e)){const t=l();t.setFormat(r.getFormatType()),t.setIndent(r.getIndent()),u.push(t),f.set(e,t),r.getChildren().forEach((e=>{t.append(e),y.add(e.getKey()),n(e)&&e.getChildrenKeys().forEach((e=>y.add(e)))})),D(r)}}else if(d.has(o.getKey())){n(o)||v(179);const e=l();e.setFormat(o.getFormatType()),e.setIndent(o.getIndent()),u.push(e),o.remove(!0)}}if(null!==s)for(let e=0;e<u.length;e++){const t=u[e];s.append(t)}let S=null;if(h(a))if(g)if(null!==s)a.insertAfter(s);else for(let e=u.length-1;e>=0;e--){const t=u[e];a.insertAfter(t)}else{const e=a.getFirstChild();if(n(e)&&(a=e),null===e)if(s)a.append(s);else for(let e=0;e<u.length;e++){const t=u[e];a.append(t),S=t}else if(null!==s)e.insertBefore(s);else for(let t=0;t<u.length;t++){const n=u[t];e.insertBefore(n),S=n}}else if(s)a.insertAfter(s);else for(let e=u.length-1;e>=0;e--){const t=u[e];a.insertAfter(t),S=t}const T=r();i(T)&&$(T.anchor)&&$(T.focus)?p(T.clone()):null!==S?S.selectEnd():e.dirty=!0}function H(e,t){const o=S(e.focus,t);return T(o)&&!o.isIsolated()||n(o)&&!o.isInline()&&!o.canBeEmpty()}function W(e,t,n,o){e.modify(t?"extend":"move",n,o)}function X(e){const t=e.anchor.getNode();return"rtl"===(o(t)?t:t.getParentOrThrow()).getDirection()}function q(e,t,n){const o=X(e);W(e,t,n?!o:o,"character")}function G(e,t,n){const o=K(e.getStyle());return null!==o&&o[t]||n}function J(t,n,o=""){let l=null;const r=t.getNodes(),s=t.anchor,c=t.focus,f=t.isBackward(),u=f?c.offset:s.offset,a=f?c.getNode():s.getNode();if(i(t)&&t.isCollapsed()&&""!==t.style){const e=K(t.style);if(null!==e&&n in e)return e[n]}for(let t=0;t<r.length;t++){const s=r[t];if((0===t||0!==u||!s.is(a))&&e(s)){const e=G(s,n,o);if(null===l)l=e;else if(l!==e){l="";break}}}return null===l?o:l}function Q(e,t){let n=e;for(;null!==n&&null!==n.getParent()&&!t(n);)n=n.getParentOrThrow();return t(n)?n:null}const V=O;export{b as $addNodeStyle,_ as $copyBlockFormatIndent,M as $ensureForwardRangeSelection,A as $forEachSelectedTextNode,J as $getSelectionStyleValueForProperty,F as $isAtNodeEnd,X as $isParentElementRTL,W as $moveCaretSelection,q as $moveCharacter,z as $patchStyleText,L as $setBlocksType,H as $shouldOverrideDefaultCharacterSelection,B as $sliceSelectedTextNodeContent,O as $trimTextContentFromAnchor,j as $wrapNodes,P as createDOMRange,k as createRectsFromDOMRange,I as getCSSFromStyleObject,K as getStyleObjectFromCSS,V as trimTextContentFromAnchor};
