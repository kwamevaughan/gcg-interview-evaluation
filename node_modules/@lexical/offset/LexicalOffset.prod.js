/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

"use strict";var e=require("lexical");function t(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var n=t((function(e){const t=new URL("https://lexical.dev/docs/error"),n=new URLSearchParams;n.append("code",e);for(let e=1;e<arguments.length;e++)n.append("v",arguments[e]);throw t.search=n.toString(),Error(`Minified Lexical error #${e}; visit ${t.toString()} for the full message or use the non-minified dev environment for full errors and additional helpful warnings.`)}));class l{constructor(e,t,n=1){this._offsetMap=e,this._firstNode=t,this._blockOffsetSize=n}createSelectionFromOffsets(t,n,l){const s=this._firstNode;if(null===s)return null;let i=t,f=n,c=r(s,i,this._blockOffsetSize),u=r(s,f,this._blockOffsetSize);if(void 0!==l&&(i=o(i,c,l,this,this._blockOffsetSize),c=r(s,i,this._blockOffsetSize),f=o(f,u,l,this,this._blockOffsetSize),u=r(s,f,this._blockOffsetSize)),null===c||null===u)return null;let a=c.key,d=u.key;const p=e.$getNodeByKey(a),g=e.$getNodeByKey(d);if(null===p||null===g)return null;let h=0,y=0,x="element",_="element";if("text"===c.type){h=i-c.start,x="text";const t=p.getNextSibling();i!==f&&h===p.getTextContentSize()&&e.$isTextNode(t)&&(h=0,a=t.__key)}else"inline"===c.type&&(a=p.getParentOrThrow().getKey(),h=f>c.start?c.end:c.start);"text"===u.type?(y=f-u.start,_="text"):"inline"===u.type&&(d=g.getParentOrThrow().getKey(),y=f>u.start?u.end:u.start);const v=e.$createRangeSelection();return null===v?null:(v.anchor.set(a,h,x),v.focus.set(d,y,_),v)}getOffsetsFromSelection(e){const t=e.anchor,n=e.focus,l=this._offsetMap,o=t.offset,r=n.offset;let s=-1,i=-1;if("text"===t.type){const e=l.get(t.key);void 0!==e&&(s=e.start+o)}else{const e=t.getNode().getDescendantByIndex(o);if(null!==e){const t=l.get(e.getKey());if(void 0!==t){s=e.getIndexWithinParent()!==o?t.end:t.start}}}if("text"===n.type){const e=l.get(n.key);void 0!==e&&(i=e.start+n.offset)}else{const e=n.getNode().getDescendantByIndex(r);if(null!==e){const t=l.get(e.getKey());if(void 0!==t){i=e.getIndexWithinParent()!==r?t.end:t.start}}}return[s,i]}}function o(e,t,n,l,o){const s=n._offsetMap,i=l._offsetMap,f=new Set;let c=e,u=t;for(;null!==u;){const e=u.key,t=s.get(e),n=u.end-u.start;if(f.add(e),void 0===t)c+=n;else{const e=t.end-t.start;e!==n&&(c+=n-e)}const l=u.prev;if(null!==l){u=l;continue}let o=u.parent;for(;null!==o;){let e=o.prev;if(null!==e){const t=e.key,n=s.get(t),l=e.end-e.start;if(f.add(t),void 0===n)c+=l;else{const e=n.end-n.start;e!==l&&(c+=l-e)}e=e.prev}o=o.parent}break}const a=n._firstNode;if(null!==a){u=r(a,e,o);let t=!1;for(;null!==u;){if(!f.has(u.key)){t=!0;break}u=u.parent}if(!t)for(;null!==u;){const e=u.key;if(!f.has(e)){const t=i.get(e),n=u.end-u.start;if(void 0===t)c-=n;else{const e=t.end-t.start;n!==e&&(c+=e-n)}}u=u.prev}}return c}function r(e,t,n){let l=e;for(;null!==l;){if(t<l.end+("element"!==l.type||0===n?1:0)){const e=l.child;if(null!==e){l=e;continue}return l}const e=l.next;if(null===e)break;l=e}return null}function s(e,t,n,l,o,r){return{child:e,end:l,key:o,next:null,parent:r,prev:null,start:n,type:t}}function i(t,l,o,r,i,u){const a=r.get(l);void 0===a&&n(3);const d=t.offset;if(e.$isElementNode(a)){const e=c(a,r),n=0===e.length,p=n?null:f(t,e,null,r,i,u);t.prevIsBlock&&!n||(t.prevIsBlock=!0,t.offset+=u);const g=s(p,"element",d,d,l,o);null!==p&&(p.parent=g);const h=t.offset;return g.end=h,i.set(l,g),g}t.prevIsBlock=!1;const p=e.$isTextNode(a),g=p?a.__text.length:1,h=s(null,p?"text":"inline",d,t.offset+=g,l,o);return i.set(l,h),h}function f(e,t,n,l,o,r){let s=null,f=null;const c=t.length;for(let u=0;u<c;u++){const c=i(e,t[u],n,l,o,r);null===f?s=c:(c.prev=f,f.next=c),f=c}return s}function c(t,l){const o=[];let r=t.__first;for(;null!==r;){const t=null===l?e.$getNodeByKey(r):l.get(r);null==t&&n(174),o.push(r),r=t.__next}return o}const u=c;exports.$createChildrenArray=c,exports.$createOffsetView=function(e,t=1,n){const o=(n||e._pendingEditorState||e._editorState)._nodeMap,r=o.get("root"),s=new Map,i=f({offset:0,prevIsBlock:!1},c(r,o),null,o,s,t);return new l(s,i,t)},exports.OffsetView=l,exports.createChildrenArray=u;
